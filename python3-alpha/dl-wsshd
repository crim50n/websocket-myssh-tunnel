#!/usr/bin/python3

from socketserver import ThreadingMixIn
from http.server import HTTPServer, SimpleHTTPRequestHandler
from threading import Thread

class ThreadingServer(ThreadingMixIn, HTTPServer):
    pass

server = ThreadingServer(('', 8023), SimpleHTTPRequestHandler)

t = Thread(target=server.serve_forever)
t.setDaemon(True)
t.start()


import asyncio, asyncssh, websockets
import json, sys

class TunnelSSHClientSession(asyncssh.SSHClientSession):
	
	def __init__(self, websocket):
		self._websocket = websocket

	def connection_made(self, chan):
		self._chan = chan

	def session_started(self):
		print('A new session logged in.', file=sys.stderr)

	def data_received(self, data, datatype):
		asyncio.async(self._websocket.send(data), loop=asyncio.get_event_loop())

	def connection_lost(self, exc):
		if exc:
			print('SSH session error: ' + str(exc), file=sys.stderr)

@asyncio.coroutine
def wait_and_close(_websocket, chan):
	try:
		yield from chan.wait_closed()
	except:
		pass
	# yield from _websocket.send()
	# yield from _websocket.close_connection()

@asyncio.coroutine
def websocket_to_channel(_websocket, conn, init_width, init_height):
	try:
		def ssh_session_factory():
			return TunnelSSHClientSession(_websocket)
		
		chan, session = yield from conn.create_session(ssh_session_factory, 'bash', term_type='xterm', term_size=(init_width, init_height), encoding=None)
		asyncio.async(wait_and_close(_websocket, chan), loop=asyncio.get_event_loop())
		while True:
			data = yield from _websocket.recv()
			if not data:
				break
			data = json.loads(data)
			if data['type'] == 'data':
				real_data = bytes.fromhex(data['request'])
				chan.write(real_data)
			chan.change_terminal_size(data['width'], data['height'])
		# chan.write_eof()
	except websockets.exceptions.ConnectionClosed:
		print('A previous session exited abnormally.', file=sys.stderr)
	except BrokenPipeError:
		print('A previous session exited normally.', file=sys.stderr)
	except:
		import traceback
		traceback.print_exc()
	finally:
		try:
			conn.close()
		except:
			pass

@asyncio.coroutine
def websocket_ssh_handler(_websocket, path):
	try:
		[null, hostname, s_port, username] = path.split('/')
		data = yield from _websocket.recv()
		data = json.loads(data)
		assert(data['type'] == 'login')
		password = data['password']
		
		conn, client = yield from asyncssh.create_connection(asyncssh.SSHClient, hostname, username=username, port=int(s_port), password=password, known_hosts=None)
		yield from websocket_to_channel(_websocket, conn, data['width'], data['height'])
	except asyncssh.misc.DisconnectError as e:
		yield from _websocket.send(e.reason)
	except:
		import traceback
		traceback.print_exc()

import ssl
ssl_context = None
# ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
# #openssl req -x509 -nodes -days 1000 -newkey rsa:2048 -keyout mycert.pem -out mycert.pem
#ssl_context.load_cert_chain('mycert.pem')
#ssl_context.verify_mode = ssl.CERT_REQUIRED
start_server = websockets.serve(websocket_ssh_handler, '0.0.0.0', 8022, ssl=ssl_context)

asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()

