#!/usr/bin/python3

import asyncio, asyncssh, websockets
import ssl, json, sys, mimetypes, os, posixpath

class TunnelSSHClientSession(asyncssh.SSHClientSession):
	
	def __init__(self, websocket):
		self._websocket = websocket

	def connection_made(self, chan):
		self._chan = chan

	def session_started(self):
		print('A new session logged in.', file=sys.stderr)

	def data_received(self, data, datatype):
		asyncio.async(self._websocket.send(data), loop=asyncio.get_event_loop())

	def connection_lost(self, exc):
		if exc:
			print('SSH session error: ' + str(exc), file=sys.stderr)


class HTTPWebSocketServerProtocol(websockets.WebSocketServerProtocol):
	
	@asyncio.coroutine
	def handler(self):
		try:
			method, path, version = (yield from self.reader.readline())[:-2].decode().split()
			if method != 'GET' or not path.startswith('/') or version != 'HTTP/1.1':
				raise
			headers = {}
			while True:
				line = (yield from self.reader.readline())[:-2]
				if line == b'':
					break
				key, content = line.decode('utf-8').split(': ', 1)
				headers[key] = content
			if 'Sec-WebSocket-Key' not in headers:
				self.do_http_response(path, headers)
				return
			feed_buffer = ('%s %s %s\r\n' % (method, path, version)).encode()
			for key in headers:
				feed_buffer += ('%s: %s\r\n' % (key, headers[key])).encode()
			self.reader._buffer = bytearray(feed_buffer + b'\r\n') + self.reader._buffer
			yield from super().handler()
		finally:
			self.writer.close()
			self.ws_server.unregister(self)
			
	
	def do_http_response(self, path, headers):
		path = path.split('?')[0]
		path = '/index.html' if path == '/' else path
		real_path = '.' + path.replace('..', '')
		if not os.path.isfile(real_path):
			raise
		ext = posixpath.splitext(path)[-1].lower()
		ctype = mimetypes.types_map[ext] if ext in mimetypes.types_map.keys() else 'application/octet-stream'
		try:
			with open(real_path, 'rb') as fp:
				response = 'HTTP/1.0 200 OK\r\nContent-type: %s\r\n\r\n' % ctype
				self.writer.write(response.encode())
				while True:
					data = fp.read(4096)
					if not data:
						break
					self.writer.write(data)
		except:
			self.writer.write('HTTP/1.0 404 Not Found\r\n\r\nFile not found'.encode())
		finally:
			self.writer.close()


@asyncio.coroutine
def wait_and_close(_websocket, chan):
	try:
		yield from chan.wait_closed()
	except:
		pass
	# yield from _websocket.close_connection()

@asyncio.coroutine
def websocket_to_channel(_websocket, conn, init_width, init_height):
	try:
		def ssh_session_factory():
			return TunnelSSHClientSession(_websocket)
		
		chan, session = yield from conn.create_session(ssh_session_factory, 'bash', term_type='xterm', term_size=(init_width, init_height), encoding=None)
		asyncio.async(wait_and_close(_websocket, chan), loop=asyncio.get_event_loop())
		while True:
			data = yield from _websocket.recv()
			if not data:
				break
			data = json.loads(data)
			if data['type'] == 'data':
				real_data = bytes.fromhex(data['request'])
				chan.write(real_data)
			chan.change_terminal_size(data['width'], data['height'])
		# chan.write_eof()
	except websockets.exceptions.ConnectionClosed:
		print('A previous session exited abnormally.', file=sys.stderr)
	except BrokenPipeError:
		print('A previous session exited normally.', file=sys.stderr)
	except:
		import traceback
		traceback.print_exc()
	finally:
		try:
			conn.close()
		except:
			pass

@asyncio.coroutine
def websocket_ssh_handler(_websocket, path):
	try:
		[null, hostname, s_port, username] = path.split('/')
		data = yield from _websocket.recv()
		data = json.loads(data)
		assert(data['type'] == 'login')
		password = data['password']
		
		conn, client = yield from asyncssh.create_connection(asyncssh.SSHClient, hostname, username=username, port=int(s_port), password=password, known_hosts=None)
		yield from websocket_to_channel(_websocket, conn, data['width'], data['height'])
	except asyncssh.misc.DisconnectError as e:
		yield from _websocket.send(e.reason)
	except ConnectionRefusedError as e:
		yield from _websocket.send('Error: Cannot connect to SSH server %s' % hostname)
	except:
		import traceback
		traceback.print_exc()


os.chdir('html/')

if not os.path.exists('../cert.pem') or os.path.getsize('../cert.pem') == 0:
	os.system('openssl req -x509 -nodes -days 3650 -subj "/CN=myssh/" -newkey rsa:2048 -keyout ../cert.pem -out ../cert.pem')

context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
context.load_cert_chain(certfile='../cert.pem')
context.set_ciphers('RSA')

start_server = websockets.serve(websocket_ssh_handler, '0.0.0.0', 8022, klass=HTTPWebSocketServerProtocol, ssl=context)
print("Hi, please visit -> https://0.0.0.0:8022")

asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()

