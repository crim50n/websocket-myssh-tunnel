#!/usr/bin/python3

import asyncio, asyncssh, websockets
import ssl, json, sys, mimetypes, os, posixpath

from concurrent.futures import ThreadPoolExecutor
io_pool_exc = ThreadPoolExecutor(max_workers=2)

security_rules = []

class TunnelSSHClientSession(asyncssh.SSHClientSession):
	
	def __init__(self, websocket):
		self._websocket = websocket

	def connection_made(self, chan):
		self._chan = chan

	def session_started(self):
		print('A new session logged in.', file=sys.stderr)

	def data_received(self, data, datatype):
		asyncio.async(self._websocket.send(data), loop=asyncio.get_event_loop())

	def connection_lost(self, exc):
		if exc:
			print('SSH session error: ' + str(exc), file=sys.stderr)


class HTTPWebSocketServerProtocol(websockets.WebSocketServerProtocol):
	
	@asyncio.coroutine
	def handler(self):
		try:
			method, path, version = (yield from self.reader.readline())[:-2].decode().split()
			if method != 'GET' or not path.startswith('/') or version != 'HTTP/1.1':
				return
			headers = {}
			while self.state == 0:
				line = (yield from self.reader.readline())[:-2]
				if line == b'':
					break
				key, content = line.decode('utf-8').split(': ', 1)
				headers[key] = content
			if 'Sec-WebSocket-Key' not in headers:
				yield from self.do_http_response(path, headers)
				return
			feed_buffer = ('%s %s %s\r\n' % (method, path, version)).encode()
			for key in headers:
				feed_buffer += ('%s: %s\r\n' % (key, headers[key])).encode()
			self.reader._buffer = bytearray(feed_buffer + b'\r\n') + self.reader._buffer
			yield from super().handler()
		finally:
			self.writer.close()
			self.ws_server.unregister(self)
	
	@asyncio.coroutine
	def do_http_response(self, path, headers):
		path = path.split('?')[0]
		path = '/index.html' if path == '/' else path
		real_path = '.' + path.replace('..', '')
		if not os.path.isfile(real_path):
			return
		ext = posixpath.splitext(path)[-1].lower()
		ctype = mimetypes.types_map[ext] if ext in mimetypes.types_map.keys() else 'application/octet-stream'
		try:
			with open(real_path, 'rb') as fp:
				response = 'HTTP/1.0 200 OK\r\nContent-type: %s\r\n\r\n' % ctype
				self.writer.write(response.encode())
				while self.state == 0:
					data = fp.read(4096)
					if not data:
						break
					yield from asyncio.get_event_loop().run_in_executor(io_pool_exc, self.writer.write, data)
		except Exception as e:
			self.writer.write('HTTP/1.0 404 Not Found\r\n\r\nFile not found'.encode())
		finally:
			self.writer.close()


@asyncio.coroutine
def wait_and_close(_websocket, chan):
	try:
		yield from chan.wait_closed()
	except:
		pass
	# yield from _websocket.close_connection()

@asyncio.coroutine
def websocket_to_channel(_websocket, conn, init_width, init_height):
	try:
		def ssh_session_factory():
			return TunnelSSHClientSession(_websocket)
		
		chan, session = yield from conn.create_session(ssh_session_factory, 'bash', term_type='xterm', term_size=(init_width, init_height), encoding=None)
		asyncio.async(wait_and_close(_websocket, chan), loop=asyncio.get_event_loop())
		while True:
			data = yield from _websocket.recv()
			if not data:
				break
			data = json.loads(data)
			if data['type'] == 'data':
				real_data = bytes.fromhex(data['request'])
				chan.write(real_data)
			chan.change_terminal_size(data['width'], data['height'])
		# chan.write_eof()
	except websockets.exceptions.ConnectionClosed:
		print('A previous session exited abnormally.', file=sys.stderr)
	except BrokenPipeError:
		print('A previous session exited normally.', file=sys.stderr)
	except:
		import traceback
		traceback.print_exc()
	finally:
		try:
			conn.close()
		except:
			pass

@asyncio.coroutine
def websocket_ssh_handler(_websocket, path):
	try:
		[null, hostname, s_port, username] = path.split('/')
		allowed = False
		for rule in security_rules:
			typ, addr, port = rule
			if typ == 'allow' and (addr == '*' or addr == hostname) and (addr == '*' or port == s_port):
				allowed = True
				break
			if typ == 'deny' and (addr == '*' or addr == hostname) and (addr == '*' or port == s_port):
				return
		print(allowed)
		if not allowed:
			return
		data = yield from _websocket.recv()
		data = json.loads(data)
		assert(data['type'] == 'login')
		password = data['password']
		
		conn, client = yield from asyncssh.create_connection(asyncssh.SSHClient, hostname, username=username, port=int(s_port), password=password, known_hosts=None)
		yield from websocket_to_channel(_websocket, conn, data['width'], data['height'])
	except asyncssh.misc.DisconnectError as e:
		yield from _websocket.send(e.reason)
	except ConnectionRefusedError as e:
		yield from _websocket.send('Error: Cannot connect to SSH server %s' % hostname)
	except:
		import traceback
		traceback.print_exc()


os.chdir('html/')

if not os.path.exists('../cert.pem') or os.path.getsize('../cert.pem') == 0:
	os.system('openssl req -x509 -nodes -days 3650 -subj "/CN=myssh/" -newkey rsa:2048 -keyout ../cert.pem -out ../cert.pem')

context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
context.load_cert_chain(certfile='../cert.pem')
context.set_ciphers('RSA')

start_server = websockets.serve(websocket_ssh_handler, '0.0.0.0', 8022, klass=HTTPWebSocketServerProtocol, ssl=context)
print("Hi, please visit -> https://0.0.0.0:8022")

@asyncio.coroutine
def blacklist_reload():
	mtime = None
	while True:
		ctime = os.path.getmtime('../security.lst')
		if ctime != mtime:
			mtime = ctime
			security_rules.clear()
			with open('../security.lst', 'r') as fp:
				while True:
					line = fp.readline()
					if not line:
						break
					line = line.strip()
					if len(line) == 0:
						continue
					parts = line.split()
					try:
						assert (len(parts) == 3)
						assert (parts[0] == 'allow' or parts[0] == 'deny')
						if parts[1] != '*':
							ipfield = parts[1].split('.')
							assert(len(ipfield) == 4)
							for i in range(4):
								ipfield[i] = int(ipfield[i])
								assert(ipfield[i] >=0 and ipfield[i] < 256)
						if parts[2] != '*':
							port = int(parts[2])
							assert(port > 0 and port < 65536)
						security_rules.append((parts[0], parts[1], parts[2]))
					except:
						print("[warning]", "skip parsing line: '%s'" % line)
				
			print("Security list get updated.")
		yield from asyncio.sleep(5)

asyncio.async(blacklist_reload(), loop=asyncio.get_event_loop())
asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()

